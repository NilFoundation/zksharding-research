# (Part 1) What We Need to Prove to L1 in the Mainnet 

**Author**: Handan Kilinc Alper ([handan.kilinc@alumni.epfl.ch](mailto:handan.kilinc@alumni.epfl.ch))  

This document is the first part of a study analyzing what must be proven to L1. Rather than proposing a specific design, it focuses on understanding the structure and guarantees of the proven statement.

The document is divided into two main sections:

1. **Introduction** ‚Äì Provides an intuitive explanation of the guarantees our proving mechanism must enforce.
2. **Formal Definition** ‚Äì Defines the proven statement rigorously and examines whether it upholds the required safety guarantees.

Finally, we evaluate whether the formalized statement fully captures the necessary security properties.

# 1. Introduction

We want to achieve Ethereum-level safety. It means that if all contracts maintained on zkSharding were deployed on L1 and the same transactions in the same order run on Ethereum, all smart contracts ended up in the same state.

What we want to achieve at minimum is that we don‚Äôt want to have a malicious state on L1. Malicious state in our case refers to a state that is obtained by non-authorized, forged transactions. 

What does non-authorized mean here formally?

In zkSharding the state is updated with respect to transactions.  We have two types of transactions: 

- **External transactions:** External transactions are created by users, and their authentication method is determined by the smart contract rules defined by the user. As long as the authentication mechanism itself is secure and the user keeps their private keys safe, these transactions cannot be forged. Since authentication is the user‚Äôs responsibility, we do not need to focus on making them unforgeable.
- **Internal transactions:** In contrast, **internal transactions** are generated by smart contracts to interact with other contracts. Unlike external transactions, they do not have a built-in authentication mechanism‚Äîonly the final state resulting from their execution matters. Because of this, we need additional measures to prove their validity which ensures they cannot be arbitrarily modified or forged.

We have described how blocks are generated and what data it holds. There are also various validity checks for a validator to check if the block is valid. Let‚Äôs list them here again. A block is valid according to a ***validator***:

- **Block Chain Order Checks:** If the previous block `PrevBlock` exists the block number `Id` is block number of `PrevBlock` plus 1 and `timestamp` is greater that `PrevBlock` ‚Äôs timestamp.
- **Fee Related Checks:** If `BaseFee` is correct i.e., calculated with this function

https://github.com/NilFoundation/nil/blob/640df7cb8bc02dd39bc6e3db9d8d84b79a7e3d3e/nil/internal/execution/fee.go#L56

- **Execution Related Checks:** This part is based on checking the correctness of state given **valid** transactions.  We can simply define this check with a function $EVM$ evaluation check which receives list of  `InTransactions`, `Config` , state `SmartContracts` and `BlockContext` as an input and outputs internal transactions `OutTransactions`  and new state `SmartContracts` . Here `BlockContext` includes block related information which are used by $EVM$.
    
    ```go
    // BlockContext provides the EVM with auxiliary information. Once provided
    // it shouldn't be modified.
    type BlockContext struct {
    	// GetHash returns the hash corresponding to n
    	GetHash GetHashFunc
    
    	// Block information
    	Coinbase    types.Address // Provides information for COINBASE
    	GasLimit    uint64        // Provides information for GASLIMIT
    	BlockNumber uint64        // Provides information for NUMBER
    	Time        uint64        // Provides information for TIME
    	BaseFee     *big.Int      // Provides information for BASEFEE (0 if vm runs with NoBaseFee flag and 0 gas price)
    	BlobBaseFee *big.Int      // Provides information for BLOBBASEFEE (0 if vm runs with NoBaseFee flag and 0 blob gas price)
    	Random      *common.Hash  // Provides information for PREVRANDAO
    }
    ```
    
- **Consensus Related Checks:** Compute `BlockHash`  and check if  `BlockHash`  and shard id signed by at least 2/3 of validators.

***In terms of L1***, a valid block implies a different meaning because it is there for safety.

What safety means informally: Safety in blockchain refers to the property that ensures honest participants always agree on the same valid state and that no invalid or conflicting transactions can be finalized.

Therefore, in terms of Ethereum, what validity implies is that no invalid transactions were executed and the state was correct. More formally, our one execution shard block is valid according to L1 if:

- If the new state `SmartContracts`  is correct i.e., $EVM$(`InTransactions, PreviousSmartContracts, BlockContext`) ‚Üí `OutTransaction, SmartContracts`
- `PrevousSmartContracts` is correct.
- All transactions in `InTransactions`  are valid:
    - If the transaction is external, its validity is defined by the smart contract.
    - If the transaction is an internal transaction, it is valid if it is the output of a contract **which has not been executed yet.**

<aside>
üí°

The validity of `BlockContext` is a different story which will be discussed later.

</aside>

Therefore, a block needed to be verified in terms of L1‚Äôs view consists of the following information:

- `SmartContractsRoot`
- `InTransactionsRoot`
- `OutTransactionsRoot`
- `BlockContext`

Additionally, L1 needs to verify that the new proven state is the continuation of the previously proven state. It should verify that the newly proven state does not invalidate blocks in the previously proven states. In other words,  forking an execution shard by skipping some blocks or modifying history should not be possible.

# 2. Formal Proven Statement Description

We define the blocks of each execution shard $i$ as $B^i$. According to the **prover**, each block $B^i$ consists of the following components:

- **Block Header**: $bhead^i$
- **State of the Block**: $st^i$ (also referred to as `SmartContracts` state)
- **Block Context**: $bcontx^i$ (also known as `BlockContext`)
- **Executed Transactions**:
    - Internal Transactions: $InTx^i$
    - External Transactions: $ExTx^i$
- **Output Transactions**: $OutTx^i$

We summarize this as:

<aside>
‚ö°

$B^i = (bhead^i, st^i, bcontx^i, InTx^i, ExTx^i, OutTx^i)$

</aside>

At this stage, we do not focus on how $B^i$ is constructed. Instead, our goal is to **formally define what the prover must prove to L1 given a sequence of blocks.**

The prover verifies the correctness of a batch ****$\mathbb{B}_\ell$. Each batch consists of **~~at least~~** consecutive  blocks from each shard. An execution shard may contribute zero or more blocks, but any blocks included must be in sequential order without gaps:

$$
\mathbb{B}_\ell = \{B^j_0,B^j_1, \ldots, B^j_{n_j}\} \quad \forall j \in\{1,\ldots,m\}
$$

where $j$ denotes the execution shard index and $n_j$ is the number of blocks in that shard's batch.

For convenience, we represent $\mathbb{B}_\ell$ as a **two-dimensional array** of size $m \times n$, where:

- $m$ is the number of execution shards.
- $n$ is the maximum number of blocks in any execution shard's batch.
- $\mathbb{B}_\ell[j][i]$ returns $B^j_i$ if  $0‚â§i‚â§n_j$, otherwise it returns `null`, indicating that the block at this index does not exist in the batch.

We commit a batch $\mathbb{B}_\ell$ with the commitment algorithm $\text{Commit}(\mathbb{B}_0, \ldots,\mathbb{B}_\ell)$ which outputs the batch commitment $gst_\ell$. Again for the sake of this section, it is not important how we commit. The important assumption related to the commitment scheme used here is the following:

<aside>
‚ÄºÔ∏è

We assume that the commitment scheme is **binding**, meaning it is **computationally infeasible** to find two different batches $\mathbb{B}_{\ell} \neq \mathbb{B}_{\ell}'$ such that $\text{Commit}(\mathbb{B}_{\ell}) = \text{Commit}(\mathbb{B}_{\ell}'$),

This ensures that each committed state uniquely corresponds to a specific batch, preventing ambiguity or fraud.

</aside>

The **L1 verification contract** receives, at a minimum, the following inputs:

- $gst_{\ell-1}, gst_{\ell}$ which are the previous batch commitment and the proven batch commitment,
- bridge-related public inputs $l2tol1Root, l1hash, nonce$ (specific details of these inputs are not relevant for this document) and
- the proof $\pi$ which attests to the validity of batch. Validity of batch is defined with the relation $\mathcal{R}$ meaning that a batch is considered valid if and only if $\Big((gst_{\ell}, gst_{\ell-1}, l2tol1Root, l1Hash); \omega\Big)$ belongs to the relation $\mathcal{R}$ defined below where $\omega$ is a witness and $(gst_{\ell}, gst_{\ell-1}, l2tol1Root, l1Hash)$ is a public input.

$$
\mathcal{R} = \Bigg\{ \Big((gst_{\ell}, gst_{\ell-1}, l2tol1Root, l1Hash); (\mathbb{B}_0, \ldots, \mathbb{B}_\ell)\Big) \quad \Big| \quad\\ \Big((gst_{\ell-1}, gst_{\ell}); (\{(B^j_{-1}, B^j_{0}, j)\}_{j=1}^m, \mathbb{B}_{\ell-1}, \mathbb{B}_{\ell})\Big) \in \mathcal{R}_\text{link}  \\  \mathbb{B}_\ell \in \mathcal{R}_{\text{unique}},\\ \forall j \in \{1,\ldots,m\},\forall k \in \{1, \ldots, n_j\}, \Big((B^j_{k-1}, B^j_k);\mathbb{B}_\ell\Big) \in \mathcal{R}_\text{block}\\ \forall tx \in B_k^j.InTx_k^j, \Big(tx; (\{\mathbb{B}_{t}, gst_t\}_{t =0}\}^\ell)\Big) \in \mathcal{R}_\text{tx-validity},\\\Big((l2tol1Tree, l1Hash, nonce, gst_\ell);\mathbb{B}_\ell\Big) \in \mathcal{R}_\text{bridge}, 
\Bigg\}
$$

We define each sub-relations below.  In short,  by proving that **$(gst_{\ell}, gst_{\ell-1}, l2tol1Root, l1Hash); \omega)$** belongs to $\mathcal{R}$**,** the prover establishes the following key properties:

1. **Batch Continuity and Global State Consistency**
    - There exists a batch **$\mathbb{B}_\ell$** that was committed in **$gst_{\ell}$**.
    - This batch follows from the previously committed batch **$\mathbb{B}_{\ell-1}$** in **$gst_{\ell-1}$**.
    - This linkage is enforced by **$\mathcal{R}_\text{link}$** which ensures execution shards cannot fork arbitrarily, they should continue from the latest blocks in the previous batch.
2. **State Transition Validity**
    - Each execution shard's blocks in **$\mathbb{B}_\ell[j]$** follow proper state transitions from the first block of $\mathbb{B}_\ell[j]$ whose link to the previous batch shown in $\mathcal{R}_\text{link}$.
    - The transitions adhere to EVM execution rules, proven via **$\mathcal{R}_\text{evm}$.**
3. **Internal Transaction Correctness**
    - All internal transactions in **$\mathbb{B}_\ell$** are valid, meaning they were either generated in the current batch or carried over correctly from previous batches.
    - Each transaction is executed **exactly once**, enforced by **$\mathcal{R}_\text{tx-validity}$** and **$\mathcal{R}_\text{unique}$**.
    
    <aside>
    üì¢
    
    The current definition of transaction validity relies on knowledge of previous batches. However, in practice, this dependency can be eliminated by integrating unexecuted transactions directly into the global state, a concept that will be discussed later.
    
    For clarity, this section presents transaction validity **without making any assumptions** about how $gst$ is constructed.
    
    </aside>
    
4. **Correctness of Bridge-Related Public Inputs**
    - The values **$l2tol1Tree, l1Hash, nonce$** are the latest stored values in **$\mathbb{B}_\ell$** within the **`L2BridgeMessenger`** contract.
    - This is verified through **$\mathcal{R}_\text{bridge}$**.

Now let us describe each sub relations in more detail:

The first four relations defines helper relations for the main relations shown in $\mathcal{R}$

1. **Binding a block of an execution shard to a batch:**  Given the public input $j$ and a block $B^j_n$, there exists a batch $\mathbb{B}_k$ where
    - $B^j_n$ is a block of the execution shard $j$ included in $\mathbb{B}_k$
    
    In terms of relation:
    
    $$
    \mathcal{R}_{\text{isBlock}} = \Bigg\{\Big(B^j_{n},j); (\mathbb{B}_{k},n)\Big) \quad \Big| \quad \mathbb{B}_{k}[j][n] = B_n^j
    \Bigg\}
    $$
    
2. **Binding the last block to the batch:** Given the public input  $B^j_n$, there exists a batch $\mathbb{B}_k$ where
    - $B^j_n$ is a block of the execution shard $j$ included in $\mathbb{B}_k$
    - It is the last block of the execution shard $j$ in the batch
        
        $$
        \mathcal{R}_{\text{last}} = \Bigg\{\Big((B^j_{n},j); (\mathbb{B}_{k},n_j)\Big) \quad \Big| \quad \Big((B^j_{n},j); (\mathbb{B}_{k},n_j)\Big) \in \mathcal{R}_\text{isBlock}, \\  \\\mathbb{B}_{k}[j][n_j+1]= null
        \Bigg\}
        $$
        
3. **Global state commitment:** Given public input $gst_\ell$ there exists $\ell$ batches such that

- $\text{Commit}(\mathbb{B}_{\ell}, \ldots, \mathbb{B}_0) = gst_{\ell}$

In terms of relation, our prover should prove the following *relation* is satisfied.

$$
\mathcal{R}_{\text{com}} = \Bigg\{ \Big(gst_{\ell}; \mathbb{B}_{\ell}, \ldots, \mathbb{B}_0\Big) \quad \Big| \quad  \text{Commit}(\mathbb{B}_{\ell}, \ldots, \mathbb{B}_0) = gst_{\ell}
\Bigg\}
$$

1. **State transition functions (STF):** Given two state roots, it shows the correctness of state transition with respect to input transactions and block context.

$$
‚Åç
$$

$$
\mathcal{R}_\text{evm} = \Bigg\{\Big((\text{root}_{k-1}^j, \text{root}_{k}^j);(st_{k-1}^j, st_{k}^j, TxList, OutTx)\Big): \\ \text{EVM}(TxList, st_{k-1}^j, bcontx_{k}^j) \rightarrow st_k^j, OutTx,\\ Root(st_{k-1}^j) = \text{root}_{k-1}^j, Root(st^j_k) = \text{root}_k^j \Bigg\}
$$

Given these four relations, we define the following:

1. **State transition proof from one block to next block:** Given blocks $B^j_{k-1}, B^j_{k}$:
    - EVM processes the block‚Äôs transaction from $B_{k-1}^j$ to $B_k^j$ correctly
    - The root of $InTx_k^j$ matches the **`InTransactionsRoot`** field in the block header:
        
        $$
         Root(InTx_k^j) = bhead_k^j.\text{InTransactionsRoot}
        $$
        
    - The root of $OutTx_k^j$ matches the **`OutTransactionsRoot`** field in the block header:
    
    $$
    Root(OutTx_k) =  bhead_k^j.\text{OutTransactionsRoot}
    $$
    
    - Correctness of the block structure(!!! Skip for now !!!)
        - $H(bhead_{k-1}^j, j) = h_{k-1}$  and $bhead_{k}^j.\text{PrevBlock} = h_{k-1}$
    
    In terms of relation:
    
    $$
    \mathcal{R}_{\text{block}} = \Bigg\{ \Big((B^j_{k-1}, B^j_k); \mathbb{B}_\ell\Big) \quad\Big| \\\Big((B^j_{k-1},j); (\mathbb{B}_{k-1},k-1)\Big), \Big((B^j_{k},j); (\mathbb{B}_{k},k)\Big) \in \mathcal{R}_\text{isBlock} \\
    \Big((bhead_{k-1}^j.\text{StRoot}, bhead_k^j.\text{StRoot});(st_{k-1}^j, st_{k}^j,InTx_{k}^j||ExTx_{k}^j, OutTx_k^j)\Big) \in \mathcal{R}_\text{evm}\\  Root(InTx_k^j||ExTx_k^j) = bhead_k^j.\text{InTransactionsRoot} \\  Root(OutTx_k^j) = bhead_k^j.\text{OutTransactionsRoot} \\ H(bhead_{k-1}^j, j) = h_{k-1}, bhead_{k}^j.\text{PrevBlock} = h_{k-1}\Bigg\}
    $$
    
    <aside>
    üëâüèª
    
    The relation $\mathcal{R}_{\text{block}}$ ensures that a block $B_k^j$ is valid **if and only if** it correctly executes the internal and external transactions according to the EVM rules, given the previous state $st_{k-1}^j$ of $B_{k-1}^j$.
    
    This guarantees that the state transitions of execution shard blocks strictly follow the EVM execution model. This guarantees that the resulting state $st_k^j$ is always valid.
    
    Additionally, since external transactions $ExTx_k^j$ are processed within the EVM, their validity is inherently checked as part of the execution.
    
    **However, this does not check the validity of internal transactions** $InTx_k^j$. Their correctness (i.e., whether they originate from a valid source and are included correctly) must be verified separately using $\mathcal{R}_{\text{tx-validity}}$.
    
    </aside>
    
2. **Linking the global states:** Given the public input $gst_{\ell}$ and $gst_{\ell-1}$,  there exists $B_{-1}^j, B^j_0$  for each execution shard $j \in \{1,\ldots, m\}$ which is part of batches $\mathbb{B}_{\ell-1},\mathbb{B}_\ell$, respectively such that 
    - $gst_{\ell-1}$ and $gst_\ell$ are the commitment of  $\mathbb{B}_{\ell-1},\mathbb{B}_\ell$, respectively
    - $B^j_{-1}$ is the **last** block of shard $j$ in $\mathbb{B}_{\ell-1}[j]$.
    - $B_0^j$ is the first block of shard $j$ in $\mathbb{B}_\ell$ if the batch $\mathbb{B}_\ell$ commits to new blocks in shard $j$.
    - $B_{-1}^j$‚Äôs next block is $B_0^j$.
    
    In terms of relation: 
    
    $$
    \mathcal{R}_{\text{link}} = \Bigg\{ \Big((gst_{\ell-1}, gst_{\ell}); (\{(B^j_{-1}, B^j_{0}, j)\}_{j=1}^m, \mathbb{B}_{0}, \ldots \mathbb{B}_{\ell})\Big) \quad \Big|\\(gst_{\ell-1}; \mathbb{B}_{\ell - 1}, \ldots, \mathbb{B}_{0}) \in \mathcal{R}_\text{com}, (gst_{\ell}; \mathbb{B}_{\ell}, \ldots, \mathbb{B}_{0}) \in \mathcal{R}_\text{com}, \forall j \in \{1,\ldots, m\}:\\\mathbb{B}_\ell[j] =\emptyset \text{ OR } \Big(((B^j_{-1},j); (\mathbb{B}_{k}, n_j)) \in \mathcal{R}_{\text{last}}, \\((B_0^j,j); (\mathbb{B}_{\ell}, 0)) \in \mathcal{R}_\text{isBlock},\\(B_{-1}^j, B_{0}^j) \in \mathcal{R}_\text{block}, \big(k = \ell-1 \text{ OR } \forall t \in \{k+1, \ldots, \ell -1\}, \mathbb{B}_t[j] = \emptyset  \big)\Big)\Bigg\}
    $$
    
    <aside>
    üëâüèª
    
    The relation $\mathcal{R}_{\text{link}}$ ensures that **execution shard blocks are correctly linked across batches**, maintaining a continuous and valid state transition. This guarantees that the latest proven state from batch $\mathbb{B}_{\ell-1}$ is extended properly by the blocks in batch$\mathbb{B}_{\ell}$.
    
    </aside>
    
3. **Uniqueness of internal transactions in the batch:** Given a batch $\mathbb{B}_\ell$, the following must hold:
    1. **Internal uniqueness:** Each block $B^j_i$ contains distinct transactions: $B^j_i.\text{InTransactions} = \text{Set}(B^j_i.\text{InTransactions})$
        
        meaning that no transaction appears more than once within the same block.
        
    2. **Batch-wide uniqueness:** No transaction in one block $B_k^m$ appears in another block $B_i^j$ in the same batch
    
    $$
    \mathcal{R}_{\text{unique}} = \Bigg\{ \mathbb{B}_\ell \quad \Big|  
    \forall i \in \{1,\ldots, n_j\}, \forall j \in\{1,\ldots,m\}, \\ 
    B^j_i.\text{InTransactions} = \text{Set}(B^j_i.\text{InTransactions}), \\
    \forall i, k \in \{1,\ldots, n_j\}, \forall j, m \in\{1,\ldots,m\},  \\
    (i \neq k \text{ or } j \neq m) \Rightarrow B^j_i.\text{InTransactions} \cap B^m_k.\text{InTransactions} = \emptyset  
    \Bigg\}
    $$
    
    <aside>
    üëâüèª
    
    The relation $\mathcal{R}_{\text{unique}}$ ensures that **internal transactions are not duplicated**
    
    within a batch. This prevents inconsistencies, replay attacks, and double execution of transactions, which are critical for maintaining the integrity of execution shards.
    
    </aside>
    
4. **Validity of an Internal Transaction in a Batch:** Given the public input $tx$, there exists consecutive global states $gst_0, gst_1, \ldots, gst_\ell$ $$ that commits to batches $\mathbb{B}_0, \mathbb{B}_1, \ldots, \mathbb{B}_\ell$, respectively such that
    - $tx$ belongs to one of the output transactions of a block in one of the batches $\mathbb{B}_t$ and it is not executed in any block in the next batches.
    
    In terms of relation:
    
    $$
    \mathcal{R}_{\text{tx-validity}} = \Bigg\{ \Big(tx; (\{\mathbb{B}_{x}, gst_x\}^\ell_{x =0})\Big)\Big| \exist t,j,n:\\ 
    tx\in B_n^j.OutTx \text{ such that }   \Big((B_n^j,j);(\mathbb{B}_t,n)\Big) \in \mathcal{R}_{\text{isBlock}}, \\ \text{if } t<\ell, \forall i=t \text{ to } \ell: \Big((gst_{i}, gst_{i+1}); (\{(B^j_{-1}, B^j_{0}, j)\}_{j=1}^m,\mathbb{B}_{0}, \ldots, \mathbb{B}_i,  \mathbb{B}_{i+1})\Big)\in \mathcal{R}_{\text{link}}, \\ \neg \big(\exists B^k, \quad \Big((B^k,k);(\mathbb{B}_i,.)\Big) \in \mathcal{R}_{\text{isBlock}}: tx \in B^k.InTx\big)\Bigg\}
    $$
    
    This relation is somewhat more complex than others. So let‚Äôs break down what it shows:
    
    **(Existence in a Proven Batch)**
    
    $$
    \exist t,j,n: \quad tx\in B_n^j.OutTx
    $$
    
    This ensures that $tx$ was created as an **outgoing transaction** of some execution shard $j$ in **$B_n^j$** at some batch $t$.
    
    **(Block Containment in a Proven Batch)**
    
    $$
    \Big((B_n^j,j);(\mathbb{B}_t,n)\Big) \in \mathcal{R}_{\text{isBlock}}
    $$
    
    - This guarantees that block **$B_n^j$** is part of a batch **$\mathbb{B}_t$**
    
     **(Linking Between Batches)**
    
    $$
    \forall i=t \text{ to } \ell: \Big((gst_{i}, gst_{i+1}); (\{(B^j_{-1}, B^j_{0}, j)\}_{j=1}^m,\mathbb{B}_{0}, \ldots, \mathbb{B}_i,  \mathbb{B}_{i+1}\Big)\in \mathcal{R}_{\text{link}}
    $$
    
    - This ensures that all batches between $t$ ****and $\ell$ are linked properly, meaning the global state transition is valid and the execution shards correctly continue from one batch to the latest proven batch $\ell$. This implies that the batch $\mathbb{B}$, which includes $B_n^j$, belongs to an already proven batch.
    
    **(Non-Duplication Check)**
    
    $$
    \neg \big(\exists B^k, \quad \Big((B^k,k);(\mathbb{B}_i,.)\Big) \in \mathcal{R}_{\text{isBlock}}: tx \in B^k.InTx\big)
    $$
    
    - This **prevents double execution** of transactions.
    - It states that $tx$ must not appear as an incoming transaction in any previously proven batch.
    
    ### 
    
5. **Correctness of Bridge-Related Public Inputs:**  Here we assume that the execution shard where the bridge contract `L2BridgeMessenger` is deployed is the execution shard $u$ and the address of `L2BridgeMessenger` is a fixed value. Additionally, the storage slots of $l2tol1Tree, l1Hash, nonce$ in `L2BridgeMessenger` ‚Äôs state are fixed.
    
    Given the public inputs $l2tol1Tree, l1Hash, nonce,gst_\ell$, there exists a block $B_{n_u}^u$ such that
    
    - $B_{n_u}^u$ is the last block of execution shard $u$ in batch $\mathbb{B}_\ell$
    - $l2tol1Tree, l1Hash, nonce$ is part of the state of `L2BridgeMessenger`  at block $B_{n_u}^u$.
    
    In terms of relation:
    
    $$
    \mathcal{R}_{\text{bridge}} = \Bigg\{ \Big((l2tol1Tree, l1Hash, nonce, gst_\ell);\mathbb{B}_\ell\Big)\quad \Big| \\ \Big((B_{n_u}^u,gst_\ell);(\mathbb{B}_\ell,n_u)\Big) \in \mathcal{R}_{\text{last}},\\st_{\text{L2msg}} \in st_{n_u}^u, (l2tol1Tree, l1Hash, nonce) \in st_{\text{L2msg}}
    \Bigg\}
    $$
    
    Here $st_{\text{L2msg}}$ represents the state of `L2BridgeMessenger` .
    
    <aside>
    üì¢
    
    $st_{n_u}^u$ and $st_{L2msg}$ are constructed with a Merkle tree. Therefore, inclusion in a state means being part of the tree in the leaves.
    
    </aside>
    

## Analysis of the Proven Statement

As we explained in the beginning, we want to achieve with our proven statement that our proven state is correctly constructed with only valid transactions. 

Now let‚Äôs analyze if there exists any probabilistic polynomial time (PPT) adversary that can find $\Big((gst_{\ell}, gst_{\ell-1}, l2tol1Root, l1Hash, nonce); (\mathbb{B}_0, \ldots, \mathbb{B}_\ell)\Big) \in \mathcal{R}$  where $gst_\ell$ commits to a state where it is constructed by violating the EVM rules or constructed with forged transactions, or excluding the blocks in the previously proven global states.

<aside>
üëâüèª

To prevent such an adversary, our proven statement must be defined so that no valid public input and witness can exist in $\mathcal{R}$ **if they contain invalid transactions or incorrect state transitions**. The structure of $\mathcal{R}$ must inherently exclude any possibility of proving a fraudulent state. We want to show this here.

</aside>

All claims below are shown under the assumption that our proving system is sound and that previously proven batches are correctly and honestly constructed.

**Claim:**  The adversary cannot produce a batch $\mathbb{B}_\ell$ which contains a block $B_i^j$ whose state is obtained by violating the EVM execution rules.

üü¢¬†Assume that the adversary has a such block $B_i^j$. In this case, it has to show that  

$\Big((B^j_{i-1}, B^j_i);\mathbb{B}_\ell\Big) \in \mathcal{R}_\text{block}$  which enforces valid EVM execution. Since the proving system is

sound, an invalid state transition cannot satisfy $\mathcal{R}_{\text{block}}$. Any attempt to include an incorrectly computed state would require forging a false proof, which contradicts the soundness assumption.

**Claim:** If an adversary tries to fork an execution shard by skipping some blocks or modifying history, they must break the binding property of the commitment scheme.

üü¢¬† The relation **$\mathcal{R}_{\text{link}}$** ensures that the first block **$B^j_0$** in the new batch $\ell$  ****is the valid successor of the last block **$B^j_{-1}$** in the previous batch $\ell-1$ by showing that they are in 

$\mathcal{R}_\text{block}$. If the adversary achieves to fork an execution shard $j$ by linking $B_0^j$ to a block $\hat{B}_{-1}^j$ which is not the last block of the last proven batch. $\mathcal{R}_\text{last}$ guarantees that $\hat{B}_{-1}^j$ must be the last block of $\mathbb{B}_{\ell-1}$. Therefore, the adversary cannot use any block in $\mathbb{B}_{\ell-1}[j]$ to fork. In this case, the adversary needs to find another batch $\mathbb{\hat{B}}_{\ell-1}$ which contains $\hat{B}_{-1}^j$ as a last block of execution shard $j$ in batch $\ell-1$ and commits to the proven state $gst_{\ell-1}$. Since our commitment scheme is binding, our PPT adversary cannot achieve this.

**Claim:**  If an invalid internal transaction $\hat{tx}$ appears in a block $\hat{B}^j$ of batch $\mathbb{B}_{\ell}$, then the adversary must either break the binding property of the commitment scheme, or break the collision resistance of the Merkle tree's hash function used in `InTransactionsRoot` and `OutputTransactionsRoot`.

üü¢¬† Invalid internal transaction $\hat{tx}$ means that either there is not any block generating this internal transaction or it is already executed in one of the blocks. 

1. In the first case we assume that $\hat{tx}$ does not belong to any output transactions of a block. In this case 
    1. either the adversary needs a block $\hat{B}_n^j$ where $\hat{tx} \in \hat{B}_n^j.OutTx$, find a batch $\mathbb{\hat{B}}_t$ which includes this block and shows that its commitment links to iteratively the latest proven state $gst_{\ell-1}$. However, this requires breaking the binding property of the commitment scheme as shown in the previous claim.
    2. or the adversary needs to show that $\hat{tx}$ in $B^j_n.OutTx$ where $B_n^j$ is a valid block of a previous batch even though  $\hat{tx}$ not in $B^j_n.OutTx$. This requires breaking the collision resistance of the hash function i.e., finding a MT path which is equal to the root.
2. In the second case
    1. either we assume that $\hat{tx}$  belongs to output transactions of a block $B_n^j$ in a batch $t< \ell$ but this transaction has been executed already. 
    
    $$
    (\{(B^j_{-1}, B^j_{0}, j)\}_{j=1}^m,\mathbb{B}_{i}, \mathbb{B}_{i+1})\Big)\in \mathcal{R}_{\text{link}}, \\ \neg \big(\exists B^k, \quad \Big((B^k,k);(\mathbb{B}_i,.)\Big) \in \mathcal{R}_{\text{isBlock}}: tx \in B^k.InTx\big)
    $$
    
    guarantees that the blocks of previously proven batches till batch $\ell$ do not has $\hat{tx}$ in their $InTx$. If the adversary is able show this even if there exists a block that that executes $\hat{tx}$ in batch $i$, it means that it either breaks the binding property by finding a forged batch $\mathbb{\hat{B}}_i$ which commits to the already proven $gst_i$  and does not include a block that executed $\hat{tx}$ so that it able to show $\{(B^j_{-1}, B^j_{0}, j)\}_{j=1}^m,\mathbb{\hat{B}}_{i}, \mathbb{B}_{i+1})\Big)\in \mathcal{R}_{\text{link}}$ or breaks the collision resistance of the hash function by showing $tx \notin B^k.InTx$.The adversary can 
    
    b. or  we assume that $\hat{tx}$  belongs to output transactions of a block $B_n^j$ in a batch $t= \ell$. Now, the adversary want to reexecute it more than once in the latest batch.  Since $\mathcal{R}_{\text{unique}}$ guarantees that all internal transactions are unique in the latest batch $\hat{tx}$ cannot be reexecuted in the same batch.