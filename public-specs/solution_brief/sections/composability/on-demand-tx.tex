\subsection{External transactions on-demand}

A high-level and step-by-step description of the processing of external transactions 
by demand is presented below (Figure 1).
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{figures/on_demand_design.pdf}
    \caption{On-demand transactions processing design}
     \label{figure:on-demand-design}
\end{figure}
We cover the most comprehensive case that will trigger the sub-sceneries with other external 
transaction types.

\begin{enumerate}
    \item A user creates an external transaction on the nil;'s cluster. That transaction 
    invokes a function marked with extcall, from the contractnatively deployed on the cluster. 
    Formally, the transaction may look like this:

    \begin{verbatim}
        {
            chainID: <nil chain ID>,
            from: <user addr>,
            to: <nil 20-bytes contract address>,
            type: "extcall",
            ....
            data: <function selector>||<input params>
        }
    \end{verbatim}

    \item The transaction is sent to the mempool;
    \item Builders on their own or with the help of searchers derive and batch transactions 
    from mempool. Then batch is sent to the proposer by auction or with the help of 
    the relayers;
    \item Proposer validates the transaction, and there can be several cases:
        \begin{enumerate}
            \item The transaction is marked as native -- no Ethereum transaction will be generated;
            \item The extcall transaction -- that is expected that there will be generated 
            some number of Ethereum transactions. User Ethereum nonce should be provided;
            \item Ethereum address as the trarget (field "to") -- there will be generated a 
            transaction on Ethereum. User Ethereum nonce and transaction signature should be 
            provided. Note that it's not mandatory for the user to provide the complete 
            transaction, as RLP-serialized data can be easily reproduced from some basic 
            metainfo and data from the user that will reduce the cost of native transactions, 
            while validators can construct transactions for cheap; 
            \item Batch of signed Ethereum transactions from the user -- the proposer is not 
            required to perform any specific actions but rather to propagate the ordered batch 
            to the sequencer.
        \end{enumerate}
    \item For the extcall transaction, each time during validation proposer detects 21-bytes 
    address, it creates a special record in temporary memory, that may
    contain: new nonce, input data, target contract, function selector, callback address 
    (if exists);
    \item When native block validation is completed, the proposer sends to the signature pool a 
    specially composed structure with prepared Ethereum transactions generated during validation 
    process;
    \item The user identified block confirmation containing their external transaction and by 
    request gets a batch of Ethereum transactions from the signature pool;
    \item There are several options to ensure the correctness of input data in L1 transactions. 
    However, the simplest and most dependable method involves compelling other 
    attestators to verify the Ethereum transaction data either. Through this process, users can 
    assess the number of signatures from the block committee that have endorsed 
    the batched transactions;
    \item The user signs Ethereum transactions from the signature pool and constructs a new 
    native transaction, consolidating L1 transactions into a batch within it. 
    Subsequently, this transaction is sent to the mempool;
    \item Upon detection of such a transaction, the proposer straightforwardly propagates the 
    batch to the sequencer.
\end{enumerate}

\subsubsection{Client application}

There will be specific changes in the client application, primarily evident in two distinct 
modules for signatures and transaction construction: one designed for Ethereum and the other 
tailored for nil;'s transactions. Even if the signature standard remains consistent, variations 
in the transaction signing process and content may arise.

Another crucial modification involves the verification module. The client application must 
verify the correctness of input data for Ethereum transactions generated by the proposer during 
the validation process of an extcall. The Ethereum transaction from the proposer should undergo 
verification before being signed to mitigate the risk of fraudulent activities. 

In addition, it makes sense for the user verification mechanism to await the finalization of the 
corresponding block. This precaution is warranted due to the absence of atomicity in 
transactions, meaning that even if a rollback occurs in nil;'s cluster, the transactions 
submitted on Ethereum may not be reverted. Consequently, waiting for block finalization adds 
an extra layer of assurance in maintaining consistency and reliability in user verification 
processes.

\subsubsection{Signature pool}

The signature pool is a temporary storage for the records of Ethereum transactions that may 
look like:
\begin{verbatim}
    H(<nil address>||<external transaction hash>) : [
        txs: {eTx1', eTx2', ...}, // non user-signed transactions -> (r, s) = (0, 0)
        sig: <aggregated signature of the committee>,
        preserve_commitment: ...,
        block_id: ....
    ]
\end{verbatim}

preserve\_commitment (prc) is a special field, that will allow removing record only when a user 
signs the transactions and send an aggregated external transaction.
It can be constructed in the following way: 
\[ prc=H(H(txs)||(user_{commitment})), \] 
where \[ user_{commitment} = H((Pb \times rand_{nonce})) \]

In this approach, the removal of an entity from the pool occurs only when the user signs the 
transactions and sends them back in the same order within the aggregated transaction. 
Additionally, the user includes their \( rand_{nonce} \), confirming their intention to 
eliminate the record.

There is no necessity for a separate network pool to store these records, as they can 
technically be housed in the same area as the transaction pool. It is evident that the load on 
the mempool will not significantly increase, given the relatively small number of Ethereum 
transactions. Moreover, temporary storage costs are incurred to prompt users to sign 
transactions from the pool. Both these considerations suggest that a standard native mempool 
can effectively be employed to manage the signature pool.

\subsubsection{Tradeoffs}
Key advantages of this design include:
\begin{enumerate}
    \item Ethereum transactions order preservation -- enabling the development of sophisticated 
    solutions. As an illustration, complex operations such as transferring funds from Ethereum 
    to \nil cluster can be seamlessly executed with just a single function call;
    \item Arbitrary function calls on L1 -- as users sign transactions explicitly, on the 
    Ethereum side everything will look as if would user directly creates and sends it;
    \item Simple implementation -- the design doesn't require difficult decisions or 
    architecture, while the implementation of the client side will not be overcomplicated;
    \item An unlimited number of Ethereum transactions per one extcall function -- as validator 
    creates transactions and increases nonce, the potential number of Ethereum transactions 
    limited only by native gas limit.
\end{enumerate}
\begin{enumerate}
    \item Active client application participation -- is not as significant a concern in practice 
    as it might initially appear, particularly for wallets and clients other than hardware 
    devices. In any scenario, transactions are retained in the signature pool until the proposer 
    confirms the submission to L1;
    \item Separation of pools -- despite the fact that division can be done virtually it may require 
    additional development efforts to support.
\end{enumerate}